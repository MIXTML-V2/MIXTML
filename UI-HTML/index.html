<html>
	<head>
		<title>Platine mixage</title>
		<link rel="stylesheet" type="text/css" href="css/design.css" media="all"/> 
	</head>
	<body>
		<script src="js/three.min.js"></script>
		
		<script src="js/renderers/Projector.js"></script>
		<script src="js/renderers/CanvasRenderer.js"></script>
		<script src="js/init_scene.js"></script>
		<script src="js/libs/stats.min.js"></script>
		<script> 
			// variable initialisation de la scène
			var scene, width, height, ratio, camera, renderer, stat;
			// tableau qui va contenir tout les objects de la scène
			var objects = [];
			var pick_object, raycaster;
			var sliderVertTouch , sliderHoriTouch = false;
			var slider_positionY, slider_positionX;
			// variable init des platines
			var radius, segments, circleGeometry, tourneDisqueD, tourneDisqueG;
			var espacementPlat;
			// variable init des sliders
			var sliderVertGeometry, sliderVolG, sliderVolD, 
			sliderHoriGeometry, sliderSpeedG, sliderSpeedD, sliderBalance;
			// variable object test
			var playlist;
			// variable des matériaux
			var plat_mat, slider_mat;
			// variable de position des platines
			var positionX = -1;
			var positionY = 0.2;
			var sliderSize = 0.2;
			// variable de la sourie
			var mouseX, mouseY, mouseDown, mouseDownX, mouseDownY;
			// fonction d'initalisation appeler depuis init_scene.js
			init();
			// fonction d'render
			render();
			//fonctions gestion de la souris
			function onDocumentMouseDown( event ) {	
				// appelle raycaster
				event.preventDefault();
				mouseDownX = event.clientX;
				mouseDownY = event.clientY;				
				var mouse3D = new THREE.Vector3( ( event.clientX / width ) * 2 - 1,  //x
												-( event.clientY / height ) * 2 + 1, //y
												0.5 );                               //z
				mouse3D.unproject( camera );
				raycaster = new THREE.Raycaster( camera.position, mouse3D.sub( camera.position ).normalize() );
				console.log(raycaster);
				var intersects = raycaster.intersectObjects( objects );
				// Change move object if hit
				if ( intersects.length > 0 ) {
				pick_object = intersects[ 0 ].object;
				intersects = 0;
					if (pick_object == sliderVolD)
						{
							slider_positionY = sliderVolD.position.y;
							sliderVertTouch = true;
							console.log( 'touch slider volume droite' );
						}
					if (pick_object == sliderVolG)
						{
							slider_positionY = sliderVolG.position.y;
							sliderVertTouch = true;
							console.log( 'touch slider volume gauche' );
						}
					if (pick_object == sliderSpeedG)
						{
							slider_positionX = sliderSpeedG.position.x;
							sliderHoriTouch = true;
							console.log( 'touch slider speed gauche' );
						}
					if (pick_object == sliderSpeedD)
						{
							slider_positionX = sliderSpeedD.position.x;
							sliderHoriTouch = true;
							console.log( 'touch slider speed droite' );
						}
				}
				mouseDown = true;
				// calcule du rendu
			}
			function onDocumentMouseUp( event ) {
				event.preventDefault();
				event.stopPropagation();
				
				mouseDown = false;
				sliderVertTouch = false;
				sliderHoriTouch = false;
				
				document.removeEventListener( 'mousemove', mousemove );
				document.removeEventListener( 'mouseup', mouseup );
				_this.dispatchEvent( endEvent );
			}
			function onDocumentMouseMove( event ) {
				if (mouseDown){
					mouseX = event.clientX;
					mouseY = event.clientY;
					if (sliderVertTouch)
						pick_object.position.y = slider_positionY - ((mouseY - mouseDownY)/(height / 4.125));
					if (sliderHoriTouch)
						pick_object.position.x = slider_positionX + ((mouseX - mouseDownX)/(width / 7));
					now = Date.now();
					delta = now - then;
					 
					if (delta > interval) {
						 
						then = now - (delta % interval);
					}
				}
				
			}
			var fps = 60;
			var now;
			var then = Date.now();
			var interval = 1000/fps;
			var delta;
			
			// Boucle de rendu toutes les modifs doivent de faire ici
			function render() {
				
				requestAnimationFrame( render );
				
				now = Date.now();
				delta = now - then;
				 
				if (delta > interval) {
					then = now - (delta % interval);
					
				}
				
				tourneDisqueD.rotation.z += 0.1;
				tourneDisqueG.rotation.z += 0.1;
				//console.log(renderer.info.render);
				renderer.render( scene, camera );
				stats.update();
			}	
		</script>
	</body>
</html>
